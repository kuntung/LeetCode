# VScode上的刷题笔记
用来记录`leetcode`的刷题笔记

# 题型分类
## 辅助栈解法
### 直方图的水量：
1. 单调栈解法[0,1,0,2,1,0,1,3,2,1,2,1],维护一个栈，使得栈内元素单调递增或者递减。本题为递减。那么，当一个新的元素需要插入的时候，如果它比栈顶元素大，那么这时候可以盛水.此时盛水容量为(index - top `- 1`) * (min(height[index], height[top--]) - height[top])
    ```c++
    test
    ```

2. [二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)
    > 单调栈法的原理：
    > 先将根右的节点逐个放入，并且除了第一个根节点外，
    > 若右子树存在，应当是一个单调递增的序列。当出现元素小于top的时候，这个值是右子树某个根节点的左节点，
    > 这时候，这个节点及其后面的所有元素值都应该小于他的根节点。
    > 因为其他的元素值要么是挂载在他的左边，要么就是在他的根节点的父节点的左子节点。
    > 那么找到此时的栈内元素中最后一个大于他的值，就是他的根节点root
    > 对于如果其他元素谁大于这个值（false）
    > 否则都进行push，并且再push的过程中都需要和栈顶元素比较
    ```c++
    stack<int> st;
        int root = INT_MAX;
        for(int i = postorder.size() - 1; i >= 0; --i)
        {
            if(postorder[i] > root) return false;
            while(!st.empty() && postorder[i] < st.top())
            {
                root = st.top();
                st.pop();
            }
            st.push(postorder[i]);
        }
    return true;
    ```
## 原地操作（数组、字符串相关）
1. [删除有序数组中的重复项II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)
    > 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

    ```c++
    class Solution {
    public:
        int work(vector<int>& nums, int k) {
            int len = 0;
            for(auto num : nums)
                if(len < k || nums[len-k] != num) //对前k个数字，直接保留，对于后面的任意数字，如果要写入的位置前k个元素不为num则可以写入
                    nums[len++] = num;
            return len;
        }
        int removeDuplicates(vector<int>& nums) {
            return work(nums, 2);
        }
    };

    //c++迭代器版本:vector<T>.erase()的使用
      
    ```

2. 简洁版：[删除有序数组中的重复项]
    > 使用[双指针的解法](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/)利用两个指针，一个指针维护新数组的下标。另一个指针负责遍历全部元素
    ```c++
    //c++迭代器版本
    class Solution {
    public:
        int removeDuplicates(vector<int>& nums) {
            vector<int>::iterator iter1 = nums.begin();
            for(; iter1 != nums.end(); iter1 ++){
                if( iter1 != nums.begin() && *iter1 == *(iter1 - 1)){
                    nums.erase(iter1);
                    iter1--;
                }
            }
            return nums.size();
        }
    };
    ```

## 二分查找法
### 二分查找的基本写法
> 要求数组元素有序排列。对于二分查找法写闭区间即[left, right]
> 
> 这样写的一个好处是，如果需要取nums[right]可以避免出现非法访问的问题。
```c++
int left = 0, right = nums.size() - 1;
int mid = 0, res = ...;
while(left <= right)
{
    mid = left + (right - left)/2;
    if(nums[mid] == target) return mid;
    else if(nums[mid] < target) left = mid + 1;
    else if(nums[mid] > target) right = mid - 1;
}

//最后需要进行边界值判断，while终止条件为left > right
if(left == nums.size()) return -1; //没有找到
return left(or right);
```

### **二分查找注意事项**
1. 类似于旋转数组题型，需要对`mid,left,right`的值进行比较，因此，当最后剩下两个元素的时候，`mid = left导致nums[left] = nums[mid]`因此需要`>=` **见搜索旋转排序数组**
### 常见题型
1. [寻找旋转排序数组中的最小元素](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
    > 数组的元素各不相同，但是可能进行了k次旋转。即最后k个元素被放置到数组前端来了
    >
    > **解题思路：**
    > 
    > 1. 暴力解法。进行一个O(N)遍历，得到最小值。
    > 2. 二分搜索法：代码如下
    ```c++
    //分析：比较mid和left以及right的关系，并且每次都记录min(mid, curMin)
    //1. left < mid < right ,缩小right
    //2. left > mid, mid < right, 缩小right
    //3. left < mid, mid > right, 改变left，这时候旋转点在后半部分
    //4. left > mid > right; 改变left
    int left = 0, right = nums.size() - 1;
        int mid = 0, minNum = 5000;
        while(left <= right) //全封闭区间解法
        { 
            mid = left + (right - left) / 2;
            minNum = min(minNum, nums[mid]);
            if(nums[mid] < nums[right]) //前半部分有序
            {
                right = mid - 1;
            }
            else
            {
                left = mid + 1;
            }
        }

    return minNum;
    
    //左闭右开的区间写法
    int left = 0, right = nums.size();
        int mid = 0, minNum = 5000;
        while(left < right)
        { 
            mid = left + (right - left) / 2;
            minNum = min(minNum, nums[mid]);
            if(nums[mid] <= nums[right - 1]) //前半部分有序
            {
                right = mid;
            }
            else
            {
                left = mid + 1;
            }
        }
    return minNum;

    ```
2. 变种：搜索最大元素呢？
    ```c++
    int left = 0, right = nums.size() - 1;
    int mid = 0;
    while(left < right) //终止条件为left = right
    {
        mid = left + (right - left)/2;
        if(nums[left] < nums[mid]) left = mid;
        else right = mid - 1;
    }

    return nums[(right + 1)% nums.size()]; //最大值在最右边
   ```
3. [寻找旋转排序数组中的最小值II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)
    > 在原有基础上，元素可能存在重复
    ```c++
    //暴力解法：O(N)循环遍历
    int findMin(vector<int>& nums) {
        int res = nums[0]; //这里初值要么为最大元素值，要么赋值为第一个元素值
        for(int i : nums)
        {
            res = min(res, i);
        }
        return res;
    }
    //二分查找法
    //全封闭区间解法
    int left = 0, right = nums.size() - 1;
    int mid = 0, minNum = INT_MAX;
    while(left <= right){
        mid = left + (right - left)/2;
        minNum = min(minNum, nums[mid]);
        while(nums[mid] == nums[right] && mid < right) right--; //跳过相同元素
        if(mid == right){ //需要对while的两个终止条件做判断
            right = mid - 1;
        }
        else{ 
            if(nums[mid] < nums[right]) right = mid -1; //while条件终止的第二种情形
            else left = mid + 1;
        } 
    }
    
    return minNum;

    //左闭右开区间写法
    int left = 0, right = nums.size();
    int mid = 0, res = INT_MAX;
    while(left < right)
    {
        mid = left + (right - left)/2;
        res = min(res, nums[mid]);
        while(nums[mid] == nums[right - 1] && mid < right-1) right--;
        if(mid == right - 1){
            right = mid;
        }
        else{
            if(nums[mid] < nums[right - 1]) right = mid;
            else left = mid + 1; //mid + 1 != right
        }
    }
    return res;    
    ```

4. [搜索旋转排序数组II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)
    > 寻找一个有重复元素，原本有序排列，但是在某个位置进行翻转后的数组中是否有`target`的存在
    > 简单版本就是`没有重复元素`

    ```C++
    //代码示例：
    //1. 暴力解法:O(N)
    //2. 二分搜索法要点：对于重复元素的处理手段，单步递增或递减
    ```

5. [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
    ```c++
    
    int left = 0, right = nums.size() - 1;
    int mid = 0;
    while(left <= right)
    {
        mid = left + (right - left)/2;
        if(nums[mid] == target) return mid;
        
        if(nums[mid] >= nums[left]) //注意这里,最后两个数的时候mid = left,因此nums[mid] = nums[left]
        {
            if(nums[mid] > target && target >= nums[left]) right = mid - 1;
            else left = mid + 1;
        }
        else
        {
            if(nums[mid] < target && target <= nums[right]) left = mid + 1;
            else right = mid - 1;
        }
    }

    return -1;
    ```
6. [面试题：搜索旋转数组](https://leetcode-cn.com/problems/search-rotate-array-lcci/)
    ```c++
    //二分解法
    ```

7. [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
   
    > 如果没有找到，返回-1，如果只有一个元素，就返回相同的索引。

## 二叉树相关
### 二叉树的遍历
1. [二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)
    > 对于二叉搜索树，满足左子树的元素值始终小于根节点的值，而右子树的值始终大于根节点的值。
    >
    > 后序遍历：左右根，导致每个子树遍历序列的最后一个元素为`根节点`
    > **分析：** 找出根节点，判断左子树的最大节点以及右子树的最小节点是否满足相关要求。
    > 
    > 相关函数：以下函数均为[first, last)
    > - lower_bound(iterator_first, iterator_last, value); //返回第一个大于等于value的下标。如果都没有则为last
    > - upper_bound(iterator_first, iterator_last, value); //返回第一个大于value的下标，如果都小于，则返回last
    > - ForwardIterator min_element (ForwardIterator first, ForwardIterator last); //默认返回合法区间的最小元素值
    > 
    > 遇到的问题：应该考虑完所有的情形
    > 1. 只有一半子树的情形[5,4,3,2,1],这时候`subLeftTree`为-1应该如何处理？**将左子树的最大值赋值为INT_MIN,右子树的最小值赋值为INT_MAX**
    > 2. 递归的条件，传入的边界值考虑

    ```c++
    bool myVerify(vector<int>& postorder, int start, int end)
    {
    //判断子树是否是二叉搜索树的后续遍历
    if(end - start <= 1) return true; //当前子树只有0或1个节点，肯定是二叉搜索树
    int root = postorder[end]; //最后一个节点一定是当前子树的根节点[后序遍历的特点]
    //得到左子树的最后一个节点位置和右子树的第一个节点位置
    int subRight = start;
    for(; subRight < end; subRight++)
    {
        if(postorder[subRight] > root){
            break;
        }
    }
    //终止位置表示右子树的第一个节点位置，如果为end，那么右子树为空
    int max_Left = INT_MIN;
    int min_Right = INT_MAX;
    if(subRight > start){ //左子树不为空
        int max_Left = *max_element(postorder.begin() + start, postorder.begin() + subRight);
    }
    if(end > subRight) 
    {min_Right = *min_element(postorder.begin() + subRight, postorder.begin() + end);}  //左闭右开
    if(max_Left > root || min_Right < root) 
        return false;
    else    
        return myVerify(postorder, start, subRight - 1)&&myVerify(postorder, subRight, end - 1);
    }   
    ```

2. [二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)
    ```c++
    //两种实现方式
    //递归：需要注意递归终止条件
        void myPostorder(TreeNode* root, vector<int>& res){
        //后续遍历实现
        if(root == nullptr) return;
        if(root->left)
        myPostorder(root->left, res); //遍历左子树
        if(root->right)
        myPostorder(root->right, res); //遍历右子树
        res.push_back(root->val);

    }
    //迭代实现：
    vector<int> postorderTraversal(TreeNode* root) {
        if (!root) return {};
        vector<int> vec;
        stack<TreeNode *> stk;
        TreeNode *prev = nullptr;
        auto node = root;
        while (!stk.empty() || node) {
            // 1.遍历到最左子节点
            while (node) {
                stk.emplace(node);
                node = node->left;
            }
            node = stk.top(); stk.pop();
            // 2.遍历最左子节点的右子树(右子树存在 && 未访问过)
            if (node->right && node->right != prev) {
                // 重复压栈以记录当前路径分叉节点
                stk.emplace(node);
                node = node->right;      
            } else {
                // 后序：填充vec在node->left和node->right后面
                // 注意：此时node的左右子树应均已完成访问
                vec.emplace_back(node->val);
                // 避免重复访问右子树[记录当前节点便于下一步对比]
                prev = node;
                // 避免重复访问左子树[设空节点]
                node = nullptr;
            }
        }
        return vec;
    }
    ```
3. [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
    > 二叉树的前序遍历为：`根左右`，因此在迭代实现的过程中，可以考虑用一个辅助栈来模拟进程。
    >
    > 先将根节点压入栈，然后压入右子树，再压入左子树，这时左子树为top，继续对左子树进行top操作

    ```c++
    void myPreorder(TreeNode* root, vector<int>& v) //递归实现
    {
        if(!root) return;
        v.push_back(root->val);
        myPreorder(root->left,v);
        myPreorder(root->right, v);
    }
    void myPreorderIterable(TreeNode* root)
    {
        //迭代实现
        if(!root) return;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        st.push(cur);
        while(!st.empty())
        {
            cur = st.top();
            st.pop();
            res.push_back(cur->val);
            if(cur->right) st.push(cur->right);
            if(cur->left) st.push(cur->left);
        }
    }
    ```

4. [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
   
    > 二叉树的中序遍历顺序为：左根右
### 二叉树的深度

1. [计算二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/solution/mian-shi-ti-55-i-er-cha-shu-de-shen-du-xian-xu-bia/)

> BFS的算法解析：
>
> **关键点：** 每遍历一层，则计数器 +1+1 ，直到遍历完成，则可得到树的深度。

**算法解析：**

- 特例处理： 当 root 为空，直接返回 深度 0 。
- 初始化： 队列 queue （加入根节点 root ），计数器 res = 0。
- 循环遍历： 当 queue 为空时跳出。
- 初始化一个空列表 tmp ，用于临时存储下一层节点；
- 遍历队列： 遍历 queue 中的各节点 node ，并将其左子节点和右子节点加入 tmp；
- 更新队列： 执行 queue = tmp ，将下一层节点赋值给 queue；
- 统计层数： 执行 res += 1 ，代表层数加 11；
- 返回值： 返回 res 即可。

```c++
//DFS实现
int maxDepth(TreeNode* root) {
    if(!root) return 0;
    int height = 1;
    return height + max(maxDepth(root->left), maxDepth(root->right));
}

//BFS实现
int maxDepth(TreeNode* root) {
    // if(!root) return 0;
    // int height = 1;
    // return height + max(maxDepth(root->left), maxDepth(root->right));
    if(!root) return 0;
    deque<TreeNode*> dq;
    int res = 0;
    dq.push_back(root);
    while(!dq.empty())
    {
        deque<TreeNode*> tempQue;  
        for(auto & node: dq) //容器遍历的新手段，还不需要创立对象，代码也简洁
        {
            if(node->left)  tempQue.push_back(node->left);
            if(node->right)  tempQue.push_back(node->right);
        }
        res++;
        dq = tempQue;
    }

    return res;
}
```

2. [平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

   > 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
   >
   > **递归细节：**最开始只想到判断两边子树的深度是否满足条件，而没有添加`isBalanced(root->left) && isBalanced(root->right);`来判断每个子树的平衡情况

   ```c++
   bool isBalanced(TreeNode* root) {
           if(!root) return true;
           return abs(getHeight(root->left) - getHeight(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
       }
   
   private:
       int getHeight(TreeNode* root)
       {
           if(!root) return 0;
           return 1 + max(getHeight(root->left), getHeight(root->right));
       }
   
   //大佬的进阶版：剪枝替代重复的运算
   
   ```

   

## 动态规划

### 相关题型

1. [第n个丑数](https://leetcode-cn.com/problems/ugly-number-ii/)

   > 解法:
   >
   > - 优先队列法（小顶堆）+去重
   > - 直接通过set（自动去重）
   > - 动态规划法：[三指针法](https://leetcode-cn.com/problems/ugly-number-ii/solution/san-zhi-zhen-fang-fa-de-li-jie-fang-shi-by-zzxn/)

   ```c++
   //第n个丑数
   int Solution::nthUglyNumber(int n) {
       //最大堆法
       priority_queue <double,vector<double>,greater<double> > q;
       double answer=1;
       for (int i=1;i<n;++i)
       {
           q.push(answer*2);
           q.push(answer*3);
           q.push(answer*5);
           answer=q.top();
           q.pop();
           while (!q.empty() && answer==q.top())
               q.pop();
       }
       return answer;
       //采用set去重的方法
       priority_queue <double,vector<double>,greater<double> > q;
       set<int> s;
       s.insert(1);
       vector<int> mask({2,3,5});
       double answer=1;
       for (int i=1;i<n;++i)
       {
           for (int &j:mask)
               if (s.count(answer*j)==0)
               {
                   q.push(answer*j);
                   s.insert(answer*j);
               }
           answer=q.top();
           q.pop();
       }
       return answer;
       //优化：直接采用set
       set<double> s;  // set 是有序的，且不重复
       double answer = 1;
       for (int i = 1; i < n; i++) {
           s.insert(answer * 2);
           s.insert(answer * 3);
           s.insert(answer * 5);
           answer = *s.begin();
           s.erase(answer);
       }
       return answer;
   
       //三指针解法
       int p2 = 0, p3 = 0, p5 = 0;
       vector<double> res(n, 0);
       res[0] = 1;
       for(int i = 1; i < n; i++)
       {
           double arr[] = {2*res[p2], 3*res[p3], 5*res[p5]};
           int temp = int(*min_element(arr, arr+3));
           res[i] = temp;
           if(temp == arr[0]) p2++;
           if(temp == arr[1]) p3++;
           if(temp == arr[2]) p5++;
       }
   
       return res[n-1];
   }
   ```

   

# 知识点总结

## 位运算
### 二进制的源码、补码、反码
1. 补码：在补码表示中，最高位为符号位，`0正1负`

2. 原码：最高位为符号位，其他位相同

3. 正整数的补码是其二进制表示，与原码相同

4. 求负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1

4. 已知一个数的补码，求原码的操作其实就是对该补码再求补码
    > 对于数-5原码：10000101, 补码：11111011
    > 已知一个补码为11111001，则原码是10000111（-7）
    
6. `&&`逻辑与的特性：短路原理

    ```c++
    //求1+2+3+...+n
    int sumNums(int n) {
        // //牛
        // bool arr[n][n+1];
        // return sizeof(arr)>>1;
        n && (n += sumNums(n-1)); //递归实现，终止条件为n == 1;
        return n;
    }
    ```

    

### 相关题型：


## 常用函数
### 上下取整函数
1. ceil:需要#include<cmath>,并且里面元素需要强转为`float`
   
    > 参考[森林中的兔子](https://leetcode-cn.com/problems/rabbits-in-forest/)

**要点：** C++中C++有符号和无符号整型（unsigned int），32位操作系统下：
- 有符号：-2147483648 ~ 2147483647
- 无符号：0~4294967295（2的32次方减1）
- 对于函数返回值类型为bool,不能通过返回数字的形式。不然容易出错。
    > 比如：返回所查找的元素是否存在[1,3,2],target = 1;
    >
    > 真实结果是找到了target1的`下标0`，但是直接返回会将0视为`false`**功能错误**

## 二分搜索法总结
1. 当数组元素有序时，采用二分搜索法。
2. 当数组元素有序，但被旋转后解法
    - 寻找旋转点，然后在每一段进行查找
    - 直接二分查找

3. 二分查找的细节问题：
    - 寻找左侧边界问题：相当于判断小于该target的元素个数。如果全部都小于该元素，则有可能溢出。应该对返回的left进行判断
    - 寻找右侧边界问题：相当于判断小于等于该target的元素个数，如果全部都大于该元素，那么返回值为—1,需要进行相关处理

    ```java
    // 查找第一个值等于给定值的元素
    private int firstEquals(int[] arr, int target) {
        int l = 0, r = arr.length - 1;
        while (l < r) {
            int mid = l + ((r - l) >> 1);
            if (arr[mid] < target) l = mid + 1;
            else r = mid; // 收缩右边界不影响 first equals
        }
        if (arr[l] == target && (l == 0 || arr[l - 1] < target)) return l;
        return -1;
    }
    // 查找最后一个值等于给定值的元素
    private int lastEquals(int[] arr, int target) {
        int l = 0, r = arr.length - 1;
        while (l < r) {
            int mid = l + ((r - l + 1) >> 1);
            if (arr[mid] > target) r = mid - 1;
            else l = mid; // 收缩左边界不影响 last equals
        }
        if (arr[l] == target && (l == arr.length - 1 || arr[l + 1] > target)) return l;
        return -1;
    }
    // 查找第一个大于等于给定值的元素
    private int firstLargeOrEquals(int[] arr, int target) {
        int l = 0, r = arr.length - 1;
        while (l < r) {
            int mid = l + ((r - l) >> 1);
            if (arr[mid] < target) l = mid + 1;
            else r = mid; // 收缩右边界不影响 first equals
        }
        if (arr[l] >= target && (l == 0 || arr[l - 1] < target)) return l; // >=
        return -1;
    }
    // 查找最后一个小于等于给定值的元素
    private int lastLessOrEquals(int[] arr, int target) {
        int l = 0, r = arr.length - 1;
        while (l < r) {
            int mid = l + ((r - l + 1) >> 1);
            if (arr[mid] > target) r = mid - 1;
            else l = mid; // 收缩左边界不影响 last equals
        }
        if (arr[l] <= target && (l == arr.length - 1 || arr[l + 1] > target)) return l; // <=
        return -1;
    }
    ```

## 二叉树相关
> 二叉树相关细节：
>
> 1. 对于二叉树，链表等问题，必须要判断数是否为空等
### 二叉树的遍历问题
1. 递归遍历：简单
2. 迭代遍历：前中后层
    - 颜色标记法
    - 辅助栈法

## string, char*以及相关转换

### string相关

1. c_str将string转为c风格字符串

   Returns a pointer to an array that contains a null-terminated sequence of characters (i.e., a C-string) representing the current value of the [string](http://www.cplusplus.com/string) object.

   This array includes the same sequence of characters that make up the value of the [string](http://www.cplusplus.com/string) object plus an additional terminating null-character (`'\0'`) at the end.

```c++
// strings and c-strings
#include <iostream>
#include <cstring>
#include <string>

int main ()
{
  std::string str ("Please split this sentence into tokens");

  char * cstr = new char [str.length()+1]; //多了一个\0
  std::strcpy (cstr, str.c_str());

  // cstr now contains a c-string copy of str

  char * p = std::strtok (cstr," ");
  while (p!=0)
  {
    std::cout << p << '\n';
    p = std::strtok(NULL," ");
  }

  delete[] cstr;
  return 0;
}
```

2. string substr (size_t pos = 0, size_t len = npos) const;

### cstring

1. int atoi (const char * str); //将c风格字符串转换为对应的int类型

2. atol

3. atof

4. int sprintf ( char * str, const char * format, ... );//将类似于printf输出格式的字符串存储在 str中，并且返回str的长度

   ```c++
   /* sprintf example */
   #include <stdio.h>
   
   int main ()
   {
     char buffer [50];
     int n, a=5, b=3;
     n=sprintf (buffer, "%d plus %d is %d", a, b, a+b);
     printf ("[%s] is a string %d chars long\n",buffer,n);
     return 0;
   }
   ```

![image-20210412212944147](C:\Users\唐昆\AppData\Roaming\Typora\typora-user-images\image-20210412212944147.png)

### to_string: Returns a [string](https://www.cplusplus.com/string) with the representation of *val*.

```c++
string to_string (int val);
string to_string (long val);
string to_string (long long val);
string to_string (unsigned val);
string to_string (unsigned long val);
string to_string (unsigned long long val);
string to_string (float val);
string to_string (double val);
string to_string (long double val);
```

## 仿函数写法

[1]. https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160

[2]. 